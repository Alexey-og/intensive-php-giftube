<?xml version="1.0" encoding="utf-8"?>
<examples>
  <example name="Модификация" index="1" sql="true">
    <description>to do</description>
    <files>
      <file name="ins.sql" main="true" show="true" tables="users,categories">
        <intro order="1">Начнем знакомиться с SQL. Вначале разберемся с запросами на модификацию данных:
        добавление, обновление и удаление записей.</intro>
        <states>
          <state order="2">За добавление записей отвечают запросы INSERT. Здесь мы указываем имя таблицы, куда добавляем
          записи. Начнем с добавления нового пользователя.</state>
          <state order="3" reload="true">Теперь нужно перечислить поля и значения для них. Строковые значения полей, в
            отличие от
          названий самих полей, требуют кавычек. Полю dt_add присваивается не строка, а результат работы функции
          для сохранения там текущей даты</state>
          <state order="4">Можно в одном запросе добавить сразу несколько записей. Для этого в скобках надо указать
          все имена полей, которые собираемся заполнять</state>
          <state order="5">После ключевого слова перечисляем в скобках значения для этих полей. Здесь мы добавляем две
          записи, которые состоят только из имени категории</state>
        </states>
      </file>
      <file name="update.sql" main="false" show="true" tables="gifs">
        <intro order="6">Посмотрим как редактировать существующие в таблицах записи</intro>
        <states>
          <state order="7">Перечисляем поля, которые редактируем, и новые значения для них. Обязательно надо указать условие,
          по которому искать запись для обновления, а в противном случае обновятся все записи в таблице</state>
          <state order="8">Редактировать можно сразу несколько полей в записи</state>
          <state order="9">Допустимо использовать старые значения поля, чтобы его модифицировать</state>
        </states>
      </file>
      <file name="del.sql" main="false" show="true" tables="categories,gifs">
        <intro order="10">В заключение научимся очищать таблицы или удалять отдельные записи</intro>
        <states>
          <state order="11">Такой запрос очистит всю таблицу. Будьте с этим осторожны!</state>
          <state order="12">Нужно указывать условие, для удаления конкретных строк</state>
          <state order="13">Этим запросом удалим все гифки, у которых меньше 10 лайков</state>
        </states>
      </file>
    </files>
  </example>
  <example name="Чтение информации" index="2" sql="true">
    <description>to do</description>
    <files>
      <file name="select.sql" main="true" show="true" tables="users,categories">
        <intro order="1">В этом уроке научимся читать информацию из таблиц. Начнём с простых запросов и будем их постепенно усложнять.</intro>
        <states>
          <state order="2">Прочитать записи очень просто. Звёздочка здесь означает показ всех полей из таблицы</state>
          <state order="3">Можно ограничить набор полей в результате, если указать их имена через запятую</state>
          <state order="4">MySQL не сортирует результаты по умолчанию. Чтобы задать сортировку по столбцу используйте
          ORDER BY, имя столбца и направление сортировки</state>
          <state order="5">Если вам не нужны абсолютно все записи из таблицы, а достаточно лишь ограниченного набора, то
          ключевое слово LIMIT позволит ограничить выборку</state>
          <state order="6">Вместе с лимитом можно задать и смещение: начиная с какой по порядку записи возвращать результаты</state>
        </states>
      </file>
      <file name="where.sql" main="false" show="true" tables="users,categories">
        <intro order="7">Узнаем, как искать информацию по условию</intro>
        <states>
          <state order="8">Читать можно не все записи, а только подходящие по какому то условию. Чтобы найти пользователя
          с конкретными именем мы используем оператор WHERE</state>
          <state order="9">Если нам не нужно точное совпадение, то можно использовать нестрогий поиск. Так мы найдем всех
          пользователей, у которых почта на gmail</state>
          <state order="10">Можно объединять несколько условий поиска в одном. Найдем всех пользователей gmail, которые
          завели аккаунт до 2019 года.</state>
          <state order="11">Вместо ключевого слова AND для поиска по диапазону используйте BETWEEN. Это работает с числами
          и датами</state>
          <state order="12">Чтобы найти записи, в которых какое либо поле не заполнено (имеет значение NULL),
            используйте специальный оператор IS NULL</state>
        </states>
      </file>
      <file name="joins.sql" main="false" show="true" tables="gifs,comments">
        <intro order="13">Таблицы можно объединять. Для этого используют джойны.</intro>
        <states>
          <state order="14">Для начала посмотрим на таблицу с комментариями. Хотелось бы видеть имя автора каждого
            комментария</state>
          <state order="15">Начнем с указания полей, которые хотим получить. Это поля из двух разных таблиц:
            комментариев и гифок</state>
          <state order="16">Осталось указать с какой таблицей объединить комментарии и по какому условию</state>
          <state order="17">Объединять можно сколько угодно таблиц, а не только две. Здесь для показа гифок нам
            понадобились
          таблицы юзеров и категорий</state>
          <state order="18">LEFT JOIN умеет присоединять запись из другой таблицы, даже если не все они соответствуют
            условию</state>
          <state order="19">Связь "многие-ко-многим" означает, что необходимую таблицу надо джойнить не
            напрямую, через специальную, промежуточную таблицу. Здесь мы показываем гифки, которые добавил в
            избранное пользователь с email tbaranov@bk.ru. Связь между пользователем и избранными гифками
            организована через таблицу gifs_fav</state>
        </states>
      </file>
    </files>
  </example>
  <example name="Группировка и агрегация данных" index="3" sql="true">
    <description>to do</description>
    <files>
      <file name="agg.sql" main="true" show="true" tables="users">
        <intro order="1">Функции агрегации используются в MySQL, когда необходимо получить новую информацию на основе
        существующих записей. Самый прстой пример: узнать количество записей в таблице</intro>
        <states>
          <state order="2">Посчитаем сколько всего у нас пользователей</state>
          <state order="3">Узнаем сумму просмотров всех гифок</state>
          <state order="4">Получим среднее число просмотров наших гифок</state>
          <state order="5">Найдем дату регистрации первого пользователя</state>
        </states>
      </file>
      <file name="group_agg.sql"  main="false" show="true" tables="gifs,categories">
        <intro order="6">Группировку записей и агрегирующие функции часто  используют вместе. Так записи можно поделить
          на отдельные  группы и получить результат для каждой группы отдельно.</intro>
        <states>
          <state order="7">Показать только те категории, по которым загружали гифки</state>
          <state order="8">Узнаем, сколько гифок находится в каждой из категорий</state>
          <state order="9">Этот запрос покажет сколько гифок загрузил каждый пользователь</state>
          <state order="10">Статистика популярности по категориям. Покажем сколько просмотров и сколько всего гифок в
          каждой из категорий</state>
        </states>
      </file>
    </files>
  </example>
  <example name="Подзапросы и функции даты" index="4" sql="true">
    <description>to do</description>
    <files>
      <file name="sub.sql" main="true" show="true" tables="gifs">
        <intro order="1">Вложенные запросы (или подзапросы) - это обычные SQL-запросы, которые могут находиться
          на месте имени поля, имени таблицы и участвовать в условиях поиска</intro>
        <states>
          <state order="2">Здесь результат выполнения вложенного запроса - список id пользователей, загрузивших
            гифки участвует в условии поиска для внешнего запроса.</state>
          <state order="3">В этом примере вложенный запрос выполняется, возвращает один результат для для
            каждого юзера из таблицы users и этот результат становится значением поля итоговой выборки</state>
          <state order="4">Здесь вложенный запрос выполняется, возвращает значение, которое используется для
            поиска во внешнем запросе</state>
        </states>
      </file>
      <file name="date.sql" main="false" show="true" tables="gifs">
        <intro order="5">В языке SQl есть множество функций для выполнения операций над датой и
          временем</intro>
        <states>
          <state order="6">Приведем дату создания гифки к привычному формату времени</state>
          <state order="7">MySQL умеет вычитать и складывать даты. Здесь мы показываем гифки, созданные за
            последние семь дней</state>
          <state order="8">Есть также функции, что возвращают год, месяц или день для переданной даты</state>
          <state order="9">Чтобы перевести дату из привычного нам формата в формат, пригодный для сохранения в
            MySQL используйте функцию STR_TO_DATE</state>
        </states>
      </file>
    </files>
  </example>
  <example name="LIKE и полнотекстовый поиск" index="5" sql="true">
    <description>to do</description>
    <files>
      <file name="like.sql" main="true" show="true" tables="gifs">
        <intro order="1">Оператор LIKE подходит для поиска без учета регистра, а также для поиска по неполной
          строке</intro>
        <states>
          <state order="2">Здесь мы находим одну запись, хотя значение поля title имеет иной регистр</state>
          <state order="3">LIKE также позволяет искать по подстроке. Знак процента % здесь означает, что после
            строки "когда" могут идти любые символы</state>
          <state order="4">LIKE не рассматривает значения именно как слова, поэтому найдутся записи, где строка
            "рыба" является частью другого слова</state>
          <state order="5">Из за этой же особенности с помощью LIKE не получится искать по нескольким отдельным
            словам</state>
        </states>
      </file>
      <file name="fulltext.sql" main="false" show="true" tables="gifs">
        <intro order="6">FULLTEXT – это специальный вид индекса, поддерживаемый в MySQL.
          Добавьте этот индекс нужным полям, чтобы организовать по ним полнотекстовый поиск</intro>
        <states>
          <state order="7">Полнотекстовый поиск позволяет искать и сортировать результаты с учетом релевантности. Сам
            показатель релевантности мы выводим в поле score
          </state>
          <state order="8">Для полнотекстового поиска используются операторы MATCH и AGAINST</state>
          <state order="9">Поиск по отдельным словам также поддерживается</state>
        </states>
      </file>
      <file name="boolean.sql" main="false" show="true" tables="gifs">
        <intro order="10">Fulltext также умеет работать в режиме логического поиска. В в этом режиме нет
          показателя релевантности, зато доступны операторы поиска</intro>
        <states>
          <state order="11">Используем плейсхолдер "звездочка", заменяющий символ в конце строки</state>
          <state order="12">Исключаем слово из результатов поиска оператором "минус"</state>
          <state order="13">Можно также искать по полному совпадению, если поместить строку в кавычки</state>
        </states>
      </file>
    </files>
  </example>
</examples>
