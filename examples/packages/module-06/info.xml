<?xml version="1.0" encoding="utf-8"?>
<examples>
  <example name="HTTP-заголовки" index="1">
    <description>to do</description>
    <files>
      <file name="headers.php" main="true" show="true">
        <intro order="1">Посмотрим как PHP умеет взаимодействовать с протоколом HTTP. Вначале разберемся как можно получить
        список из всех заголовков запроса. </intro>
        <states>
          <state order="2">Вначале объявим список заголовков, которые нас интересуют. Дадим каждому заголовку
            описательное имя
          </state>
          <state order="3">В цикле для каждого заголовка получим имя ключа в массиве $_SERVER</state>
          <state order="4">Проверяем, что в массиве $_SERVER есть заголовок с таким ключом</state>
          <state order="5" reload="true">Выводим на экран описание каждого заголовка вместе с его значением</state>
        </states>
      </file>
      <file name="headers2.php" main="false" show="true">
        <intro order="6">С помощью PHP можно также просматривать заголовки ответа, менять их и даже добавлять свои
        собственные.</intro>
        <states>
          <state order="7">Отправлять можно не только стандартные, существующие заголовки. Никто не запрещает нам
            придумать свой собственный заголовок и отправить его вместе с остальными.
          </state>
          <state order="8" reload="true">Чтобы посмотреть какие заголовки ответа будут отправлены вашим скриптом используйте функцию
            headers_list(). Она вернет массив из всех заголовков.
          </state>
          <state order="9" reload="true">Часто бывает необходимо переадресовать пользователя на другую страницу после выполнения
            какого нибудь действия. Например, после успешной аутентификации на сайте. Отправка специального
            заголовка ответа "Location" заставит браузер пользователя перейти по адресу из этого заголовка.
          </state>
        </states>
      </file>
    </files>
  </example>
  <example name="Параметры запроса" index="2">
    <description>to do</description>
    <files>
      <file name="index.php" main="true" show="true">
        <intro order="1">Посмотрим где может быть полезен первичный идентификатор записи. Мы сделаем две вкладки
        на главной странице, которые нужны для сортировки гифок по популярности, либо по дате создания.</intro>
        <states>
          <state order="3">Определим переменную, где будет указано поле для сортировки. По умолчанию сортируем по числу
          просмотров.</state>
          <state order="4">Получаем параметр запроса с именем "tab". Если этот параметр запроса имеет значение "tab", то сортировка будет выполняться по полю dt_add
          </state>
          <state order="5">Формируем запрос на показ гифок, где в качестве поля для сортировки передаем переменную.</state>
          <state order="6" reload="true">Выполняем запрос и показываем результат на странице.
          </state>
        </states>
      </file>
      <file name="templates/main.php" main="false" show="true">
        <intro order="2">Шаблон главной страницы. Здесь есть две ссылки - "топовые гифки" и "свежачок", которые
        ведут на главную страницу. Но вторая ссылка также содержит параметр запроса для показа самых новых записей.</intro>
        <states/>
      </file>
        <file name="init.php" main="false" show="false">
            <states/>
        </file>
        <file name="templates/layout.php" main="false" show="false">
            <states/>
        </file>
    </files>
  </example>
  <example name="Данные из формы" index="3">
    <description>to do</description>
    <files>
      <file name="add.php" main="true" show="true">
        <intro order="1">Разберемся с тем, как работают подготовленные выражения на примере разработки страницы
          для добавления гифки. Все полученные из формы данные будут записываться в БД только через подготовленные
          выражения.</intro>
        <states>
          <state order="3">Скопируем POST массив в новую переменную</state>
          <state order="4">Займемся сохранением файла. Вначале придумаем ему новое имя. Запишем в массив для
            сохранения это имя. И наконец переместим загруженный файл из временной папки в постоянное место
            хранения</state>
          <state order="5">Формируем SQL запрос на добавление новой гифки. Обратите внимание, что на месте значений
            располагаются знаки вопроса - плейсхолдеры.
          </state>
          <state order="6">
            С помощью функции-помощника сформируем подготовленное выражение, на основе SQL-запроса и значений
            для него. Вторым шагом выполняем полученное выражение.
          </state>
          <state order="8" reload="true">Если запрос выполнен успешно, то получаем ID новой гифки и перенаправляем
            пользователя на
            страницу с её просмотром
          </state>
          <state order="9" reload="true">Иначе подключаем шаблон для показа ошибки и передаем туда текст последней
            MySQL ошибки
          </state>
        </states>
      </file>
      <file name="templates/add.php" main="false" show="true">
        <intro order="2">Это просто шаблон с формой добавления гифки. В качестве данных здесь используется лишь
          список категорий. Этот список нужен для формирования выпадающего меню с выбором категории.</intro>
        <states/>
      </file>
      <file name="functions.php" main="false" show="true">
        <intro order="7">Функция db_get_prepare_stmt нужна, чтобы упростить работу с подготовленными выражениями.
          Она сама определит тип данных и сформирует выражение на основе переданного SQL запроса и вернет его.
          Затем такое выражение останется только лишь выполнить.</intro>
        <states/>
      </file>
    </files>
  </example>
  <example name="Валидация формы" index="4">
    <description>to do</description>
    <files>
      <file name="add.php" main="true" show="true">
        <intro order="1">Мало просто отправить форму и получить из неё значения. Любые данные, введенные в форму
        пользователям обязательно нужно проверять. Такой процесс называется валидацией формы.</intro>
        <states>
          <state order="2">Вначале убедимся, что форма была отправлена. Для этого проверяем метод, которым была
            запрошена страница. Если метод POST - значит этот сценарий был вызван отправкой формы
          </state>
          <state order="3">Мы должны определить список обязательных к заполнению полей. Также мы определяем пустой массив $errors, который будем заполнять ошибками валидации
          </state>
          <state order="4">Определим функции-помощники для валидации и поля, которые они должны обработать</state>
          <state order="6">Получим в массив три поля из формы. Если какого то поля не будет в форме, то в массиве его значением будет NULL</state>
          <state order="7">Применяем функции валидации ко всем полям формы. Результат работы функций записывается в массив
            ошибок. Данный массив мы в итоге отфильтровываем, чтобы удалить от туда пустые значения и оставить
            только сообщения об ошибках. В этом же цикле мы проверяем заполненность обязательных к заполнению полей</state>
          <state order="8">Проверим, был ли загружен файл. Поле для загрузки файла в форме называется 'gif_img', поэтому
            нам следует искать в массиве $_FILES одноименный ключ. Если таковой найден, то мы можем получить
            имя загруженного файла
          </state>
          <state order="9">С помощью стандартной функции finfo_ можно получить информацию о типе файле</state>
          <state order="10">Если тип загруженного файла не является Gif-анимацией, то добавляем новую ошибку в список
            ошибок валидации
          </state>
          <state order="11">Если файл соответствует ожидаемому типу, то мы копируем его в директорию где лежат все
            гифки,
            а также добавляем путь к загруженной гифки в массив $gif
          </state>
          <state order="12">Загрузка файла - обязательное условие успешной валидации формы. Поэтому если он не был
            загружен, добавляем ошибку
          </state>
          <state order="13">Здесь мы проверяем длину массива с ошибками. Если он не пустой, значит были ошибки и мы
            должны показать их пользователю вместе с формой. Для этого подключаем шаблон формы и передаем
            туда массив, где будут заполненные поля, а также список ошибок
          </state>
          <state order="15">Если ошибок не было, то далее процесс стандартный: сформировать запрос с данными из
            формы, выполнить его и переадресовать пользователя на страницу просмотра.</state>
          <state order="16">Если метод не POST, значит форма не была отправлена и валидировать ничего не надо, поэтому
            просто подключаем шаблон показа формы
          </state>
          <state order="17" reload="true">Подключаем лейаут и передаем туда шаблон страницы. Выводим результат на
            экран</state>
        </states>
      </file>
      <file name="templates/add.php" main="false" show="true">
        <intro order="14">Мы добавили в шаблон с формой показ отправленных значений, а также ошибок валидации.
        Кроме того, каждое поле с ошибкой подсвечивается красным цветом. За это отвечает класс с "form__input--error".
        Весь список ошибок валидации показывается под формой.</intro>
        <states/>
      </file>
      <file name="templates/view.php" main="false" show="false">
        <states/>
      </file>
      <file name="templates/layout.php" main="false" show="false">
        <states/>
      </file>
      <file name="functions.php" main="false" show="true">
        <intro order="5">Здесь мы определили в том числе те самые функции-помощники для валидации отдельных
          полей</intro>
        <states/>
      </file>
    </files>
  </example>
</examples>
