<?xml version="1.0" encoding="utf-8"?>
<examples>
  <example name="Простые массивы" index="1" mode="replace">
    <description>to do</description>
    <files>
      <file name="array.php" main="true" show="true">
        <intro order="1">В этой демке мы разберем все основные операции с простыми массивами. Научимся их создавать,
          заполнять, читать от туда значения проверять существование элементов. Определить новый массив можно либо
          пустым, либо сразу заполнив его значениями.
        </intro>
        <states>
          <state order="2" reload="true">Т.к. массив содержит список значений, его нельзя вывести на экран как простую переменную</state>
          <state order="3" reload="true">Чтобы узнать что содержится в массиве (для отладочных целей) можно воспользоваться функциями
            var_dump или print_r
          </state>
          <state order="4" reload="true">Все значения массива можно преобразовать в строку, где эти значения будут разделены
            специальным символом. Например, запятой
          </state>
          <state order="5" reload="true">Чтобы получить значение из массива необходимо указать его индекс. Индексация значения
            начинается с нуля, т.е. индекс первого значения массива всегда будет равен нулю.
          </state>
          <state order="6" reload="true">Чтобы получить последнее значение, необходимо узнать его индекс. Для этого надо узнать общее
            кол-во элементов и отнять единицу.
          </state>
          <state order="7" reload="true">Для добавления нового значения в конец массива используйте литерал 'пустые скобки'</state>
          <state order="8" reload="true">Вы можете обновить любой элемент в массиве указав его индекс и присвоив новое значение
          </state>
          <state order="9" reload="true">Используйте функцию array_unshift, чтобы добавить новый элемент в начало массива</state>
          <state order="10" reload="true">Для удаления элементов из массива существует функция unset, которой надо передавать индекс
            удаляемого элемента
          </state>
          <state order="11" reload="true">Чтобы узнать, есть ли в массиве элемент с определенным индексом используйте функцию isset
          </state>
          <state order="12" reload="true">Для проверки существования значения в массиве используйте функцию in_array</state>
          <state order="13" reload="true">Чтобы 'забрать' первый элемент массива существует функция array_shift. Она возвращает первый
            элемент и одновременно удаляем его из массива
          </state>
          <state order="14" reload="true">Функция array_merge умеет объединять два массива в один</state>
          <state order="15" reload="true">Элементы массива можно сортировать, т.е. менять их порядок. Например, можно отсортировать,
            расположив элементы в алфавитном порядке их значений
          </state>
          <state order="16" reload="true">
            Фунцкцию explode вы будете очень часто использовать в своей работе. Она умеет создавать массив на основе строки.
            Если у вас есть строка сс значениями, разделенными отдельными символами, то explode преобразует эту строку в массив.
          </state>
          <state order="17" reload="true">
            Специальная конструкция list() умеет создавать переменные и присваивать им значения из массива. Значения
            присваиваются по порядку.
          </state>
        </states>
      </file>
      <file name="dummy" show="false" main="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Ассоциативные массивы" index="2">
    <description>to do</description>
    <files>
      <file name="array_assoc.php" main="true" show="true">
        <intro order="1">Рассмотрим другой вид массивов - ассоциативные. В таких массивах можно хранить значения,
          под именованным ключом.
        </intro>
        <states>
          <state order="2" reload="true">Добавлять новое значение в ассоциативный массив надо вместе с ключом. Если в массиве не было
            такого ключа, то это значение добавится, а если было - заменится
          </state>
          <state order="3" reload="true">Прочитать значение из ассоциативного массива можно также как и из простого, только вместо
            индекса используйте ключ
          </state>
          <state order="4" reload="true">Замена значений не отличается от добавления новых</state>
          <state order="5" reload="true">Чтобы получить последнее значение из ассоциативного массива, надо вначале получить его ключи,
            определить последний ключ и использовать его для получения значения
          </state>
        </states>
      </file>
      <file name="dummy" show="false" main="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Двумерные массивы" index="3">
    <description>to do</description>
    <files>
      <file name="two_array.php" main="true" show="true">
        <intro order="1">Двумерные массивы полезны для хранения списков, состоящих из сложных значений.
          Например, список юзеров, где каждый юзер имеет имя, возраст и электронную почту.
        </intro>
        <states>
          <state order="2">Наш первый двумерный массив состоит из двух обычных, ассоциативных массивов</state>
          <state order="3">Вы можете создать двумерный массив, объявив вложенные ассоциативные массивы прямо в момент
            создания первого
          </state>
          <state order="4">Двумерный массив - это простой массив, каждый элемент которого - массив ассоциативный.
            Поэтому, чтобы получить значение любого из вложенных массивов необходимо вначале указать индекс,
            под которым он сохранен, а затем интересующий ключ
          </state>
        </states>
      </file>
      <file name="dummy" show="false" main="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Циклы" index="4" mode="replace">
    <description>to do</description>
    <files>
      <file name="loops.php" main="true" show="true">
        <intro order="1">Изучим работу циклов - структуры языка для выполнения участка кода больше одного раза.</intro>
        <states>
          <state order="2" reload="true">Перед вами самый простой цикл. Он умеет выводить все цифры от 1 до 9 включительно.
            Цикл выполняется, пока значение в переменной $last_num будет меньше 10 - это задано в условии
            цикла. В теле цикла мы выводим текущее значение переменной, а затем увеличиваем её на единицу
          </state>
          <state order="3" reload="true">Тот же цикл, что и в прошлом примере, но здесь мы выводим все цифры в HTML-списке.
            Обратите внимание на альтернативную форму записи цикла. Она применяется при работе с HTML кодом
          </state>
          <state order="4">Циклы часто используются для перебора массивов. В этом примере с помощью цикла на страницу
            выводятся все значения из массива $categories
          </state>
          <state order="5">Опять тот же пример, но на этот раз весь массив категорий выводим в виде HTML-списка</state>
          <state order="6">foreach - это другой вид циклов. Цикл foreach создан специально для удобного перебора всех
            ключей и значений любого массива. Здесь мы с его помощью обходим ассоциативный массив и показываем
            на странице каждый его ключ и значение.
          </state>
          <state order="7">А вот и самый комплексный пример. Здесь у нас двумерный массив, цикл foreach и работа с HTML
            кодом. Благодаря всем этим возможностям мы можем сформировать HTML-страницу, где будет список гифок
          </state>
        </states>
      </file>
    </files>
  </example>
  <example name="Функции" index="5">
    <description>to do</description>
    <files>
      <file name="cut_str.php" main="true" show="true">
        <intro order="1">В этой демонстрации создадим свою функцию для обрезания строки.</intro>
        <states>
          <state order="2">Давайте сделаем какую нибудь полезную функцию. Функция cut_text() будет обрезать строку текста
            до определенной длины и добавлять в конец знак многоточия.
          </state>
          <state order="3">Определим два аргумента - сама строка, которую надо обрезать и необходимая длина</state>
          <state order="4">Для начала узнаем длину переданной строки</state>
          <state order="5">Напишем условие, которое будет выполняться только если длина строки больше необходимой</state>
          <state order="6">С помощью встроенной функции mb_substr обрежем строку до необходимой длины и добавим в конец
          знак троеточия</state>
          <state order="7">Вернем результат</state>
          <state order="8" reload="true">Проверим что получилось. Выполним функцию, передав туда тестовую строку и ограничение длины
          в 25 символов</state>
        </states>
      </file>
      <file name="cut_str_v2.php" show="true" main="false">
        <intro order="9">Посмотрим на две интересные возможности, которые можно применить к аргументам функции</intro>
        <states>
          <state order="10">Снова сделаем функцию для обрезания строки, но на этот раз она будет работать немного иначе</state>
          <state order="11">Первому аргументу мы добавили амперсанд. Это означает, что теперь такой аргумент передается по
          ссылке. В этом случае функция будет работать не с копией этой переменной, а изменять её значение напрямую.
          Второму аргументу задали значение по умолчанию. Оно будет использовано, если при вызове функции данный аргумент
          опустить.</state>
          <state order="12">Тело функции оставили почти без изменений. Единственное отличие - функция теперь ничего не
          возвращает</state>
          <state order="13" reload="true">Вызовем функцию. Теперь значение переменной $text поменялось сразу после вызова функции.</state>
          <state order="14" reload="true">В этом примере мы не указали длину строки, поэтому функция использовала значение по умолчанию - 30</state>
        </states>
      </file>
      <file name="anonym.php" show="true" main="false">
        <intro order="15">Посмотрим где могут пригодиться и как использовать анонимные функции</intro>
        <states>
          <state order="16">Напишем функцию, которая будет конвертировать регист символов из строки случайным образом</state>
          <state order="17">Переведем строку в массив</state>
          <state order="18">Функция array_walk обходит массив и применяет к каждому элементу переданную функцию.</state>
          <state order="19">Случайным образом меняем регистр текущего символа</state>
          <state order="20">Преобразуем массив символов обратно в строку и возвращаем её</state>
          <state order="21" reload="true">Выполняем функцию и смотрим что получилось</state>
        </states>
      </file>
    </files>
  </example>
</examples>
